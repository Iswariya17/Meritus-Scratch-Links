const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const Clone = require('../../util/clone');
const Cast = require('../../util/cast');
const Timer = require('../../util/timer');
const nets = require('nets');
const iconURI = "data:image/png;base64,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UmVhZHlxyWU8AAADI2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDYwLCAyMDIwLzA1LzEyLTE2OjA0OjE3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0RDNzdERjZEODlFMTFFQThFOEVBOUU2MjBDNkNDMEEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0RDNzdERjdEODlFMTFFQThFOEVBOUU2MjBDNkNDMEEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3REM3N0RGNEQ4OUUxMUVBOEU4RUE5RTYyMEM2Q0MwQSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3REM3N0RGNUQ4OUUxMUVBOEU4RUE5RTYyMEM2Q0MwQSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Puq/WnIAABVISURBVHja7JwHWFRX2sf/d3qnDjPAAFJEAaVYUcSIhaixxEY0tsQkJpbUz89EEo092ZhsxBijscZUe++u0aCiKIiiIlJEkDYw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";


let image;

const Runtime = require('../../engine/runtime');
const formatMessage = require('format-message');
const Video = require('../../io/video');
const VideoState = {
    /** Video turned off. */
    OFF: 'off',

    /** Video turned on with default y axis mirroring. */
    ON: 'on',

    /** Video turned on without default y axis mirroring. */
    ON_FLIPPED: 'on-flipped'
};

//server info
let classifyURL = 'https://cognimate.me:2635/vision/classify';
let updateURL = 'https://cognimate.me:2635/vision/updateClassifier';
// let classifyURL = 'http://localhost:2634/vision/classify';
// let updateURL = 'http://localhost:2634/vision/updateClassifier';

//classifier_id
let classifier_id = 'general1234';
let api_key = 'ddce01b8a0504adaa59157533ea77747';

//for parsing image response
let watson_response; //the full response
let classes; //the classes and scores returned for the watson_response
let image_class; //the highest scoring class returned for an image

//response when updating a classifier
let update_response;

//image that user takes
let videoElement;
let imageData;
let _track;

class Scratch3Watson {
    constructor (runtime) {
        /**
         * The runtime instantiating this block package.
         * @type {Runtime}
         */
        this.runtime = runtime;

        /**
         * The last millisecond epoch timestamp that the video stream was
         * analyzed.
         * @type {number}
         */
        this._lastUpdate = null;
        this._lastFrame = undefined;


        if (this.runtime.ioDevices) {
            // Clear target motion state values when the project starts.
            // this.runtime.on(Runtime.PROJECT_RUN_START, this.reset.bind(this));

            // Kick off looping the analysis logic.
            this._loop();

            // Configure the video device with values from a globally stored
            // location.
            this.setVideoTransparency({
                TRANSPARENCY: this.globalVideoTransparency
            });
            // this.videoToggle({
            //     VIDEO_STATE: this.globalVideoState
            // });

            this.videoToggle({
                VIDEO_STATE: 'off'
            });
        }
    }

    /**
     * After analyzing a frame the amount of milliseconds until another frame
     * is analyzed.
     * @type {number}
     */
    static get INTERVAL () {
        return 33;
    }

    /**
     * Dimensions the video stream is analyzed at after its rendered to the
     * sample canvas.
     * @type {Array.<number>}
     */
    static get DIMENSIONS () {
        return [480, 360];
    }

    /**
     * The transparency setting of the video preview stored in a value
     * accessible by any object connected to the virtual machine.
     * @type {number}
     */
    get globalVideoTransparency () {
        const stage = this.runtime.getTargetForStage();
        if (stage) {
            return stage.videoTransparency;
        }
        return 50;
    }

    set globalVideoTransparency (transparency) {
        const stage = this.runtime.getTargetForStage();
        if (stage) {
            stage.videoTransparency = transparency;
        }
        return transparency;
    }

    /**
     * The video state of the video preview stored in a value accessible by any
     * object connected to the virtual machine.
     * @type {number}
     */
    get globalVideoState () {
        const stage = this.runtime.getTargetForStage();
        if (stage) {
            return stage.videoState;
        }
        return VideoState.ON;
    }

    set globalVideoState (state) {
        const stage = this.runtime.getTargetForStage();
        if (stage) {
            stage.videoState = state;
        }
        return state;
    }

    /**
     * Occasionally step a loop to sample the video, stamp it to the preview
     * skin, and add a TypedArray copy of the canvas's pixel data.
     * @private
     */
    _loop () {
        setTimeout(this._loop.bind(this), Math.max(this.runtime.currentStepTime, Scratch3Watson.INTERVAL));

        // Add frame to detector
        const time = Date.now();
        if (this._lastUpdate === null) {
            this._lastUpdate = time;
        }
        const offset = time - this._lastUpdate;
        if (offset > Scratch3Watson.INTERVAL) {
            const frame = this.runtime.ioDevices.video.getFrame({
                format: Video.FORMAT_IMAGE_DATA,
                dimensions: Scratch3Watson.DIMENSIONS
            });
            if (frame) {
                this._lastUpdate = time;
                this._lastFrame = frame;
                // this.detect.addFrame(frame.data);
            }
        }

    }

    /**
     * Create data for a menu in scratch-blocks format, consisting of an array
     * of objects with text and value properties. The text is a translated
     * string, and the value is one-indexed.
     * @param {object[]} info - An array of info objects each having a name
     *   property.
     * @return {array} - An array of objects with text and value properties.
     * @private
     */
    _buildMenu (info) {
        return info.map((entry, index) => {
            const obj = {};
            obj.text = entry.name;
            obj.value = entry.value || String(index + 1);
            return obj;
        });
    }

    /**
     * States the video sensing activity can be set to.
     * @readonly
     * @enum {string}
     */
    static get VideoState () {
        return VideoState;
    }

    get VIDEO_STATE_INFO () {
        return [
            {
                name: formatMessage({
                    id: 'videoSensing.off',
                    default: 'off',
                    description: 'Option for the "turn video [STATE]" block'
                }),
                value: VideoState.OFF
            },
            {
                name: formatMessage({
                    id: 'videoSensing.on',
                    default: 'on',
                    description: 'Option for the "turn video [STATE]" block'
                }),
                value: VideoState.ON
            },
            {
                name: formatMessage({
                    id: 'videoSensing.onFlipped',
                    default: 'on flipped',
                    description: 'Option for the "turn video [STATE]" block that causes the video to be flipped' +
                        ' horizontally (reversed as in a mirror)'
                }),
                value: VideoState.ON_FLIPPED
            }
        ];
    }
    getInfo () {
        return {
            id: 'vision',
            name: 'CV pro w Scratch',
            blockIconURI: iconURI,
            blocks: [
                {
                    opcode: 'videoToggle',
                    text: formatMessage({
                        id: 'vision.video',
                        default: 'turn video [VIDEO_STATE]',
                        description: ''
                    }),
                    arguments: {
                        VIDEO_STATE: {
                            type: ArgumentType.NUMBER,
                            menu: 'VIDEO_STATE',
                            defaultValue: VideoState.ON
                        }
                    }
                },
                {
                    opcode: 'setAPI',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.setAPI',
                        default: 'Set API key to',
                        description: ''
                    }) + ' [KEY]',
                    arguments:{
                        KEY:{
                            type: ArgumentType.STRING,
                            defaultValue: formatMessage({
                                id: 'general.key',
                                default: 'key',
                                description: ''
                            })
                        }
                    }
                },
                {
                    opcode: 'getModelfromString',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.getModelfromString',
                        default: 'Choose image model',
                        description: ''
                    }) + ': [IDSTRING]',
                    //[THIS] needs to be equal to THIS in arguments
                    arguments: {
                        IDSTRING: {
                            type: ArgumentType.STRING,
                            defaultValue: formatMessage({
                                id: 'vision.modelId',
                                default: 'model id',
                                description: ''
                            })
                        }
                    }
                },
                {
                    opcode: 'setGenModel',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.choosePreTrained',
                        default: 'Choose pre-trained model',
                        description: ''
                    }),
                    //[THIS] needs to be equal to THIS in arguments
                    arguments: {
                        IDSTRING: {
                            type: ArgumentType.STRING,
                            defaultValue: formatMessage({
                                id: 'vision.modelId',
                                default: 'model id',
                                description: ''
                            })
                        }
                    }
                },
                {
                    opcode: 'takePhoto',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.takePhoto',
                        default: 'Take photo from webcam',
                        description: ''
                    })
                },
                {
                    opcode: 'urlPhoto',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.searchImage',
                        default: 'Search image using link',
                        description: ''
                    }) + ' [URL]',
                    arguments:{
                        URL: {
                            type: ArgumentType.STRING,
                            defaultValue: formatMessage({
                                id: 'vision.addLink',
                                default: 'add link here',
                                description: ''
                            })
                        }
                    }
                },
                {
                    opcode: 'recognizeObject',
                    blockType: BlockType.REPORTER,
                    text: formatMessage({
                        id: 'vision.whatDoYouSee',
                        default: 'What do you see in the photo?',
                        description: ''
                    })
                },
                {
                    opcode: 'recognizeObjectCommand',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.searchPrediction',
                        default: 'Search prediction for your photo',
                        description: ''
                    })
                },
                {
                    opcode: 'getScore',
                    blockType: BlockType.REPORTER,
                    text: formatMessage({
                        id: 'vision.howSure',
                        default: 'How sure are you the photo is a [CLASS]?',
                        description: ''
                    }),
                    arguments:{
                        CLASS: {
                            type: ArgumentType.STRING,
                            defaultValue: formatMessage({
                                id: 'general.addCategory',
                                default: 'add category here',
                                description: ''
                            })
                        }
                    }
                },
                {
                    opcode:'trackLabel',
                    blockType: BlockType.HAT,
                    text: formatMessage({
                        id: 'vision.whenImageIs',
                        default: 'When image is [LABEL]',
                        description: ''
                    }),
                    arguments:{
                        LABEL:{
                            type: ArgumentType.STRING, 
                            defaultValue: formatMessage({
                                id: 'general.addCategory',
                                default: 'add category here',
                                description: ''
                            })
                        }
                    }
                },
                {
                    opcode: 'clearResults',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.clearResults',
                        default: 'Clear results',
                        description: ''
                    })
                },
                {
                    opcode: 'updateClassifier',
                    blockType: BlockType.COMMAND,
                    text: formatMessage({
                        id: 'vision.addPhoto',
                        default: 'Add photo to [LABEL]',
                        description: ''
                    }),
                    arguments:{
                        LABEL:{
                            type: ArgumentType.STRING,
                            defaultValue: formatMessage({
                                id: 'general.addCategory',
                                default: 'add category here',
                                description: ''
                            })
                        }
                    }
                }

            ],
            menus: {
                models: ['Default','RockPaperScissors'],
                VIDEO_STATE: this._buildMenu(this.VIDEO_STATE_INFO)
            }
        };
    }

    getModelfromString (args, util){
        if(args.IDSTRING !== 'classifier id'){
            classifier_id = args.IDSTRING;
        }
    }

    setGenModel (args, util){
        classifier_id = 'general1234';
    }

    getScore(args, util){
        //check that classes is not empty
        if(classes === null){
            return 'did you classify an object yet?'
        }
        var comparison_class = args.CLASS.toLowerCase();
        //make sure the class entered is valid
        console.log(classes);
        console.log(comparison_class);
        if(!classes.hasOwnProperty(comparison_class)){
            return 'this is not a valid class'
        }
        return classes[comparison_class];
    }

    takePhoto (args, util) {
        imageData = this.runtime.ioDevices.video.getSnapshot();
        console.log(imageData);
    }

    recognizeObjectCommand(args, util){
        return this.recognizeObject();
    }

    recognizeObject(args,util) {
        if(imageData == null){
            return 'No Image set';
        }
        if(api_key == null){
            return 'No api key set';
        }
        if(classifier_id == null){
            return 'No Classifier ID set';
        }

        image_class = null
        let image = imageData;

        if (this._lastImage === image &&
            this._lastResult !== null) {
            return this._lastResult;
        }

        this._lastImage = image;
        const _this = this;
        let promise = new Promise((resolve)=>{
        this.classify(classifier_id, image,
            function(err, response) {
            if (err){
                console.log(err);
            }
            else {
                watson_response = JSON.parse(response.body, null, 2);
                console.log(watson_response);
                classes = {};
                //store everything
                for (var i = 0, length = watson_response.length; i < length; i++) {
                    classes[watson_response[i].class.toLowerCase()] = watson_response[i].score;
                }
                //figure out the highest scoring class
                var class_label;
                var best_score = 0;
                for (var key in classes) {
                    if (classes.hasOwnProperty(key)) {
                        if(classes[key]>best_score){
                            best_score = classes[key];
                            class_label = key;
                        }
                    }
                }

                image_class = class_label;
                _this._lastResult = image_class;
                resolve(image_class);
            }});
        });
        promise.then(output => output);

        return promise;
      }

    parseResponse(input){
        for (var i = 0, length = input.length; i < length; i++) {
            classes[input[i].class] = input[i].score;
        }
        //figure out the highest scoring class
        var class_label;
        var best_score = 0;
        for (var key in classes) {
            if (classes.hasOwnProperty(key)) {
                if(classes[key]>best_score){
                    best_score = classes[key];
                    class_label = key;
                }
            }
        }
        return class_label;
    }

    classify(classifier, image, callback) {
        var formData = JSON.stringify({classifier_id: classifier, image_data:image});
        console.log(formData);
        if(image.substring(0,4) === 'data'){
            nets({
                url: classifyURL,
                headers: {
                  'apikey': api_key,
                  'Content-Type': 'application/json' // important header to be included henceforth
                }, // couldn't figure out how to get x-url-encoded content-type to work
                method: 'POST',
                body: formData,
                encoding: undefined // This is important to get response as a string otherwise it returns a buffer array
              }, function(err, response){
                  console.log(response);
                    callback(err, response);
            });
        } else{
            // let url_classify_url = "http://localhost:2634/vision/classifyURLImage";
            let url_classify_url = "https://cognimate.me:2635/vision/classifyURLImage";
            nets({
                url: url_classify_url,
                headers: {'apikey': api_key,
                    'Content-Type': 'application/json'
                },
                method: 'POST',
                body: formData,
                encoding: undefined
                }, function(error, response){
                    console.log(response);
                    callback(error, response);
                });
        }
    }


    setAPI(args, util){
        api_key = args.KEY
    }

    urlPhoto(args,util){
        if(args.URL === 'add link here'){
            return 'invalid link'
        } else{
            imageData = args.URL;
        }
    }

    clearResults () {
        image_class = null;
        imageData = null;
        classes = {};
    }

    trackLabel(args, util){
        let label = args.LABEL;
        if(label == image_class){
            return true;
        } else {
            return false;
        }
    }
    updateClassifier(args, util){
        let category = args.LABEL;
        let promise = new Promise((resolve)=>{
            var formData = JSON.stringify({classifier_id: classifier_id, images:[imageData], class: category});
            this.updateRequest(formData, function(err, response) {
                if (err){
                    console.log(err);
                }
                else {
                    resolve(JSON.parse(response.body));
                }
            });
        });
        promise.then(output => output);
        return promise;
    }

    updateRequest(formData, callback){
        nets({
            url: updateURL,
            headers: {
            'apikey': api_key,
            'Content-Type': 'application/json' // important header to be included henceforth
            }, // couldn't figure out how to get x-url-encoded content-type to work
            method: 'POST',
            body: formData,
            encoding: undefined // This is important to get response as a string otherwise it returns a buffer array
        }, function(err, response){
            console.log(response);
            callback(err, response);
        });
    }

    videoToggle (args) {
        const state = args.VIDEO_STATE;
        this.globalVideoState = state;
        if (state === VideoState.OFF) {
            if(videoElement){
                trackerTask.stop();
                videoElement.pause();
                _track.stop();
                videoElement = null;
                _track = null;
            }
            this.runtime.ioDevices.video.disableVideo();
        } else {
            // this._setupVideo();
            this.runtime.ioDevices.video.enableVideo();
            // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.
            this.runtime.ioDevices.video.mirror = state === VideoState.ON;
        }
    }

    /**
     * A scratch command block handle that configures the video preview's
     * transparency from passed arguments.
     * @param {object} args - the block arguments
     * @param {number} args.TRANSPARENCY - the transparency to set the video
     *   preview to
     */
    setVideoTransparency (args) {
        const transparency = Cast.toNumber(args.TRANSPARENCY);
        this.globalVideoTransparency = transparency;
        this.runtime.ioDevices.video.setPreviewGhost(transparency);
    }
}

module.exports = Scratch3Watson;
